# 队列的原理

- 队列是限制在两端进行插入操作和删除操作的线性表
- 允许进行存入操作的一端称为“队尾”
- 允许进行删除操作的一端称为“队头”
- 当线性表中没有元素时，称为“空队”
- 特点 ：==先进先出==（FIFO）

> 双端队列也可当作栈来处理 												

![image-20221018004435898](https://raw.githubusercontent.com/zfr010503/huaqing/master/img/202210231630091.png)

### 队列的一般规定

1. front指向队头元素的位置; rear指向队尾元素的下一个位置。
2. 在队列操作过程中，为了提高效率，以调整指针代替队列元素的移动，并将数组作为==循环队列==的操作空间。
3. **为区别空队和满队，满队元素个数比数组元素个数少一个**。

### 队列判满和判空

- 判满：**(sq->rear + 1) % N == sq->front**
- 判空：**rear == front**

# ==顺序队列==的实现（C语言）

### 顺序队列结构体

```c
typedef struct {
	datatype data[N];
	int front;
	int rear;
}sequeue;
```

### 创建队列

```c
sequeue * queue_create() {
	sequeue *sq;

    if ((sq = (sequeue *)malloc(sizeof(sequeue))) == NULL) {
        printf("malloc failed\n");
        return NULL;
    }

    memset(sq->data, 0, sizeof(sq->data));
    sq->front = sq->rear = 0;
    return sq;
}
```

### 入队

```c
int enqueue(sequeue *sq, datatype x) {
	if (sq == NULL) {
		printf("sq is NULL\n");
		return -1;
	}

    if ((sq->rear + 1) % N == sq->front) {
        printf("sequeue is full\n");
        return -1;
    }

    sq->data[sq->rear] = x;
    sq->rear = (sq->rear + 1) % N;

    return  0;
}
```

### 出队

```c
datatype dequeue(sequeue *sq) {
	datatype ret;

    ret = sq->data[sq->front];

    sq->front = (sq->front + 1) % N;

    return ret;
}
```

### 判空

```c
int queue_empty(sequeue *sq) {
	if (sq == NULL) {
		printf("sq is NULL\n");
		return -1;
	}

	return (sq->front == sq->rear ? 1 : 0);
}
```

### 判满

```c
int queue_full(sequeue *sq) {
	if (sq == NULL) {
		printf("sq is NULL\n");
		return -1;
	}

    if ((sq->rear + 1) % N == sq->front) {
        return 1;
    }
    else {
        return 0;
    }
}
```

### 清空队列

```c
int queue_clear(sequeue *sq) {
	if (sq == NULL) {
		printf("sq is NULL\n");
		return -1;
	}

    sq->front = sq->rear = 0;
    return 0;
}
```

### 删除队列

```c
sequeue * queue_free(sequeue *sq) {
	if (sq == NULL) {
		printf("sq is NULL\n");
		return NULL;
	}
    free(sq);
    sq = NULL;

    return NULL;
}
```

# 链式队列的实现（C语言）

### 链式队列结构体

```c
typedef int datatype;

typedef struct node {
	datatype data;
	struct node *next;
}listnode , *linklist;

typedef struct {
	linklist front;
	linklist rear;
}linkqueue;
```

### 创建队列

```c
linkqueue * queue_create() {
	linkqueue *lq;

    if ((lq = (linkqueue *)malloc(sizeof(linkqueue))) == NULL) {
        printf("malloc linkqueue failed\n");
        return NULL;
    }

    lq->front = lq->rear = (linklist)malloc(sizeof(listnode));
    if (lq->front == NULL) {
        printf("malloc node failed\n");
        return NULL;
    }
    lq->front->data = 0;
    lq->front->next = NULL;

    return lq;
}
```

### 入队

```c
int enqueue(linkqueue *lq, datatype x) {
	linklist p;

    if (lq == NULL) {
        printf("lq is NULL\n");
        return -1;
    }

    if ((p = (linklist)malloc(sizeof(listnode))) == NULL) {
        printf("malloc node failed\n");
        return -1;
    }
    p->data = x;
    p->next = NULL;

    lq->rear->next = p;
    lq->rear = p;

    return 0;
}
```

### 出队

```c
datatype dequeue(linkqueue *lq) {
	linklist p;

    if (lq == NULL) {
        printf("lq is NULL\n");
        return -1;
    }

    p = lq->front;
    lq->front = p->next;
    free(p);
    p = NULL;

    return (lq->front->data);
}
```

### 判空

```c
int queue_empty(linkqueue *lq) {
	if (lq == NULL) {
		printf("lq is NULL\n");
		return -1;
	}

	return (lq->front == lq->rear ? 1 : 0);
}
```

### 清空队列

```c
int queue_clear(linkqueue *lq) {
	linklist p;

    if (lq == NULL) {
        printf("lq is NULL\n");
        return -1;
    }

    while (lq->front->next) {
        p = lq->front;
        lq->front = p->next;
        printf("clear free:%d\n", p->data);
        free(p);
        p = NULL;
    }
    return 0;
}
```

### 删除队列

```c
linkqueue * queue_free(linkqueue *lq) {
	linklist p;

    if (lq == NULL) {
        printf("lq is NULL\n");
        return NULL;
    }

    while (lq->front) {
        p = lq->front;
        lq->front = p->next;
        printf("free:%d\n", p->data);
        free(p);
    }

    free(lq);
    lq = NULL;

    return NULL;
}
```

# 顺序队列的假溢出



出队$a1、a2$，则front指针指向下标为2的位置，rear不变，如下图所示，再入队$a5$，此时front指针不变，rear指针移动到数组之外。嗯？数组之外，那将是哪里？

![这里写图片描述](https://img-blog.csdn.net/20151021163556035)

问题还不止于此。假设这个队列的总个数不超过5个，但目前如果接着入队的话，因数组末尾元素已经占用，再向后加，就会产生数组越界的错误，可实际上，我们的队列在下标为0和1的地方还是空闲的。我们把这种现象叫做**“==假溢出==”！！！！！！**。

为了解决这个问题，引入了**循环队列**的概念。
