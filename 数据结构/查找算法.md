# 查找概述

### 查找概念

设记录表$L=(R1 R2……Rn)$，其中$Ri(l≤i≤n)$为记录，对给定的某个值k，在表L中确定key=k的记录的过程，称为查找。

若表L中存在一个记录R~i~的key=k，记为R~i~.key=k，则查找成功，返回该记录在表L中的序号i(或R~i~ 的地址)，否则(查找失败)返回0(或空地址Null)。

### 查找方法

常见的七种查找方法有**顺序查找、二分查找、插值查找、树表查找、分块查找、(Hash表)哈希查找**等等。

查找算法的优劣将影响到计算机的使用效率，应根据应用场合选择相应的查找算法。

### 查找-平均查找长度

对查找算法，主要分析其T(n)。查找过程是key的比较过程，时间主要耗费在各记录的key与给定k值的比较上。比较次数越多，算法效率越差（即T(n)量级越高），故用“比较次数”刻画算法的T(n)。

平均查找长度**ASL**（Average Search Length）：对给定**k**，查找表**L**中记录比较次数的期望值(或平均值)，即：

![image-20221020142226607](https://raw.githubusercontent.com/zfr010503/huaqing/master/img/202210231628238.png)

P~i~为查找R~i~的概率。等概率情况下P~i~=1/n；C~i~为查找R~i~时key的比较次数(或查找次数)。 

# 顺序查找

### 基本思想

​	顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。

### 复杂度分析

​	查找成功时的平均查找长度为：（假设每个数据元素的概率相等） $ASL = 1/n(1+2+3+…+n) = (n+1)/2$ ;
当查找不成功时，需要n+1次比较，时间复杂度为$O(n)$;

所以，顺序查找的时间复杂度为**$O(n)$**。

### C++实现

```c++
//顺序查找
int SequenceSearch(int a[], int value, int n)

{
   int i;
   for(i=0; i<n; i++)
       if(a[i]==value)
            return i;
   return -1;
}
```

# 二分查找

### 基本思想

​	也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。

​	注：折半查找的前提条件是需要**有序表顺序存储**，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要**频繁执行插入或删除操作**的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。

### 复杂度分析

最坏情况下，关键词比较次数为$log2(n+1)$，且期望时间复杂度为$O(log2n)$；

### C++实现

```c++
//二分查找（折半查找），版本1
int BinarySearch1(int a[], int value, int n)
{
    int low, high, mid;
    low = 0;
    high = n-1;
    while(low<=high)
    {
        mid = (low+high)/2;
        if(a[mid]==value)
            return mid;
        if(a[mid]>value)
            high = mid-1;
        if(a[mid]<value)
            low = mid+1;
    }
    return -1;
}

//二分查找，递归版本
int BinarySearch2(int a[], int value, int low, int high)
{
    int mid = low+(high-low)/2;
    if(a[mid]==value)
        return mid;
    if(a[mid]>value)
        return BinarySearch2(a, value, low, mid-1);
    if(a[mid]<value)
        return BinarySearch2(a, value, mid+1, high);
}
```

# 插值查找

​	折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的）。二分查找中查找点计算如下：
$$
mid=(low+high)/2, 即mid=low+1/2*(high-low)
$$
​	通过类比，我们可以将查找的点改进为如下：
$$
mid=low+(key-a[low])/(a[high]-a[low])*(high-low)
$$

> 也就是将上述的比例参数1/2改进为自适应的，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。

### 基本思想

​	基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。

　注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。

### 复杂度分析

​	查找成功或者失败的时间复杂度均为$O(log2(log2n))$。

# 分块查找

### 基本思想

将 n 个数据元素"按块有序"划分为 m 块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须"按块有序"；即第 1 块中任一元素的关键字都必须小于第 2 块中任一元素的关键字；而第 2 块中任一元素又都必须小于第 3 块中的任一元素

# ==哈希查找==

- 顺序、折半、分块查找和树表的查找中，其ASL的量级在$O(n)～O(log2n)$之间。
- 不论ASL在哪个量级，都与记录长度n有关。随着n的扩大，算法的效率会越来越低。
- ASL与n有关是因为记录在存储器中的存放是随机的，或者说**记录的key与记录的存放地址无关**，因而查找只能建立在key的“比较”基础上。

### 什么是哈希(Hash)表

理想的查找方法是：对给定的k，不经任何比较便能获取所需的记录，其查找的时间复杂度为**常数级O(C)**。

这就要求在建立记录表的时候，确定记录的key与其存储地址之间的关系f，即使key与记录的存放地址H相对应：

![image-20221020172439024](https://raw.githubusercontent.com/zfr010503/huaqing/master/img/202210231628239.png)

> 当要查找key=k的记录时，通过关系f就可得到相应记录的地址而获取记录，从而**免去了key的比较过程**。
>
> 这个关系f就是所谓的**Hash函数（或称散列函数、杂凑函数）**，记为H(key)。
>
> 它实际上是一个地址映象函数，其自变量为记录的key，函数值为记录的**存储地址（或称Hash地址）**。

- 说白了，hash函数就是根据key计算出应该存储地址的位置，而哈希表是基于哈希函数建立的一种查找表

### 哈希函数的构造方法

选取（或构造）Hash函数的方法很多，原则是尽可能将记录均匀分布，以减少冲突现象的发生。以下介绍几种常用的构造方法。

- 直接地址法
- 平方取中法
- 叠加法
- ==保留除数法==
- 随机函数法

### 哈希冲突

​	不同的key可能得到同一个Hash地址，即当$key1≠key2$时，可能有$H(key1)=H(key2)$，此时称$key1$和$key2$为**同义词**。这种现象称为“**冲突**”或“碰撞”，因为一个数据单位只可存放一条记录。

> ​	一般，选取Hash函数只能做到使冲突尽可能少，却不能完全避免。这就要求在出现冲突之后，寻求适当的方法来解决冲突记录的存放问题。

hash函数解决冲突的方法有以下几个常用的方法：

- 开放定制法
- 链地址法
- 公共溢出区法
- 再散列法

<u>冲突现象的发生有时并不完全是由于Hash函数的随机性不好引起的，聚积的发生也会加重冲突。</u>

<u>还有一个因素是表的**装填因子α**，α=n/m，其中m为表长，n为表中记录个数。一般**α在0.7～0.8**之间，使表保持一定的空闲余量，以减少冲突和聚积现象。</u>

![image-20221020173557081](https://raw.githubusercontent.com/zfr010503/huaqing/master/img/202210231628240.png)

![image-20221020173624323](https://raw.githubusercontent.com/zfr010503/huaqing/master/img/202210231628241.png)

==链式哈希是重点！！！==

![image-20221020173637599](https://raw.githubusercontent.com/zfr010503/huaqing/master/img/202210231628243.png)

# 作业

### 顺序表的特点

1. 随机访问，即可以在 O (1) 时间内找到第 i 个元素。
2. 存储密度高，每个节点只存储数据元素。
3. 拓展容量不方便（即使使用动态分配的方式实现，拓展长度的时间复杂度也比较高，因为需要把数据复制到新的区域）。
4. 插入删除操作不方便，需移动大量元素： O(n)